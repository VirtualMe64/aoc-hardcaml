(* Generated by Gemini (then fixed by me since Gemini hallucinated several apis/syntaxes) *)
open Hardcaml
open Hardcaml.Signal
open Hardcaml_waveterm

(* -------------------------------------------------------------------------- *)
(* 1. Define the States                                                       *)
(* -------------------------------------------------------------------------- *)
module State = struct
  type t =
    | Idle
    | Write_10
    | Write_20
    | Req_Read_0
    | Latch_0_Req_1
    | Latch_1
    | Done
  [@@deriving sexp_of, compare, enumerate]
end

(* -------------------------------------------------------------------------- *)
(* 2. Define the Interface                                                    *)
(* -------------------------------------------------------------------------- *)
module I = struct
  type 'a t = {
    clock : 'a;
    clear : 'a;
    start : 'a;
  } [@@deriving sexp_of, hardcaml]
end

module O = struct
  type 'a t = {
    result : 'a[@bits 8];
    valid : 'a;
  } [@@deriving sexp_of, hardcaml]
end

(* -------------------------------------------------------------------------- *)
(* 3. Hardware Logic                                                          *)
(* -------------------------------------------------------------------------- *)
let create (i : _ I.t) =
  (* Create the State Machine using the proper Module *)
  (* Note: We pass the register spec for the state variable itself here *)
  let r_sync = Reg_spec.create ~clock:i.clock ~clear:i.clear () in
  let sm = Always.State_machine.create (module State) ~enable:vdd r_sync in

  (* Wires for driving the RAM *)
  (* default:gnd means we only need to set them to 1 when active *)
  let ram_we    = Always.Variable.wire ~default:gnd in
  let ram_waddr = Always.Variable.wire ~default:(of_int ~width:2 0) in
  let ram_wdata = Always.Variable.wire ~default:(of_int ~width:8 0) in
  let ram_raddr = Always.Variable.wire ~default:(of_int ~width:2 0) in

  (* Registers to hold our results *)
  let val_a = Always.Variable.reg ~width:8 r_sync in
  let val_b = Always.Variable.reg ~width:8 r_sync in
  let valid = Always.Variable.reg ~width:1 r_sync in

  (* Instantiate the RAM *)
  let ram_out = 
    Ram.create 
      ~collision_mode:Read_before_write
      ~size:4
      ~write_ports:[| { write_clock = i.clock; write_enable = ram_we.value; write_address = ram_waddr.value; write_data = ram_wdata.value } |]
      ~read_ports:[| { read_clock = i.clock; read_enable = vdd; read_address = ram_raddr.value } |]
      ()
  in
  let ram_rdata = ram_out.(0) in

  (* State Machine Logic *)
  Always.(compile [
    sm.switch [
      (* 1. Idle: Wait for start signal *)
      State.Idle, [
        when_ i.start [ sm.set_next State.Write_10 ]
      ];

      (* 2. Write 10 to Address 0 *)
      State.Write_10, [
        ram_we    <-- vdd;
        ram_waddr <-- (of_int ~width:2 0);
        ram_wdata <-- (of_int ~width:8 10);
        sm.set_next State.Write_20;
      ];

      (* 3. Write 20 to Address 1 *)
      State.Write_20, [
        ram_we    <-- vdd;
        ram_waddr <-- (of_int ~width:2 1);
        ram_wdata <-- (of_int ~width:8 20);
        sm.set_next State.Req_Read_0;
      ];

      (* 4. Request Read for Address 0 *)
      State.Req_Read_0, [
        ram_raddr <-- (of_int ~width:2 0);
        (* Data will be available in the NEXT cycle (Latch_0_Req_1) *)
        sm.set_next State.Latch_0_Req_1;
      ];

      (* 5. Latch Data 0 AND Request Read for Address 1 *)
      State.Latch_0_Req_1, [
        val_a     <-- ram_rdata;          (* Capture value 10 *)
        ram_raddr <-- (of_int ~width:2 1); (* Request value 20 *)
        sm.set_next State.Latch_1;
      ];

      (* 6. Latch Data 1 *)
      State.Latch_1, [
        val_b <-- ram_rdata;              (* Capture value 20 *)
        sm.set_next State.Done;
      ];

      (* 7. Output Valid *)
      State.Done, [
        valid <-- vdd;
        sm.set_next State.Idle;
      ];
    ]
  ]);

  (* Outputs *)
  { O.
    result = val_a.value +: val_b.value;
    valid = valid.value;
  }

(* -------------------------------------------------------------------------- *)
(* 4. Testbench                                                               *)
(* -------------------------------------------------------------------------- *)

module Simulator = Cyclesim.With_interface(I)(O)

let () =
  let sim = Simulator.create create 
  in
  let _waves, sim = Waveform.create sim in
  
  let i = Cyclesim.inputs sim in
  let o = Cyclesim.outputs sim in

  let step () = Cyclesim.cycle sim in

  (* Reset sequence *)
  i.clear := Bits.vdd; step ();
  i.clear := Bits.gnd; step ();

  (* Trigger Start *)
  i.start := Bits.vdd; step ();
  i.start := Bits.gnd;

  (* Run simulation *)
  Printf.printf "Starting Simulation...\n";
  for _ = 0 to 12 do
    step ();
    let result = Bits.to_int !(o.result) in
    let is_valid = Bits.to_int !(o.valid) in
    
    if is_valid = 1 then
      Printf.printf "Result = %d (Expected 30)\n" result
  done;
  
  (* Uncomment to save waveform if needed *)
  (* Waveform.serialize waves "ram_sum.hardcamlwave" *)